/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/FileSaver.js":
/*!***************************!*\
  !*** ./libs/FileSaver.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*\n * FileSaver.js\n * A saveAs() FileSaver implementation.\n *\n * By Eli Grey, http://eligrey.com\n *\n * License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)\n * source  : http://purl.eligrey.com/github/FileSaver.js\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nvar _global = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && window.window === window ? window : (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self.self === self ? self : (typeof __webpack_require__.g === \"undefined\" ? \"undefined\" : _typeof(__webpack_require__.g)) === 'object' && __webpack_require__.g.global === __webpack_require__.g ? __webpack_require__.g : this;\n\nfunction bom(blob, opts) {\n  if (typeof opts === 'undefined') opts = {\n    autoBom: false\n  };else if (_typeof(opts) !== 'object') {\n    console.warn('Deprecated: Expected third argument to be a object');\n    opts = {\n      autoBom: !opts\n    };\n  } // prepend BOM for UTF-8 XML and text/* types (including HTML)\n  // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\n  if (opts.autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(0xFEFF), blob], {\n      type: blob.type\n    });\n  }\n\n  return blob;\n}\n\nfunction download(url, name, opts) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', url);\n  xhr.responseType = 'blob';\n\n  xhr.onload = function () {\n    saveAs(xhr.response, name, opts);\n  };\n\n  xhr.onerror = function () {\n    console.error('could not download file');\n  };\n\n  xhr.send();\n}\n\nfunction corsEnabled(url) {\n  var xhr = new XMLHttpRequest(); // use sync to avoid popup blocker\n\n  xhr.open('HEAD', url, false);\n\n  try {\n    xhr.send();\n  } catch (e) {}\n\n  return xhr.status >= 200 && xhr.status <= 299;\n} // `a.click()` doesn't work for all browsers (#465)\n\n\nfunction click(node) {\n  try {\n    node.dispatchEvent(new MouseEvent('click'));\n  } catch (e) {\n    var evt = document.createEvent('MouseEvents');\n    evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n    node.dispatchEvent(evt);\n  }\n} // Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\n\n\nvar isMacOSWebView = /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent);\nvar saveAs = _global.saveAs || ( // probably in some web worker\n(typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== 'object' || window !== _global ? function saveAs() {\n  /* noop */\n} // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView\n: 'download' in HTMLAnchorElement.prototype && !isMacOSWebView ? function saveAs(blob, name, opts) {\n  var URL = _global.URL || _global.webkitURL;\n  var a = document.createElement('a');\n  name = name || blob.name || 'download';\n  a.download = name;\n  a.rel = 'noopener'; // tabnabbing\n  // TODO: detect chrome extensions & packaged apps\n  // a.target = '_blank'\n\n  if (typeof blob === 'string') {\n    // Support regular links\n    a.href = blob;\n\n    if (a.origin !== location.origin) {\n      corsEnabled(a.href) ? download(blob, name, opts) : click(a, a.target = '_blank');\n    } else {\n      click(a);\n    }\n  } else {\n    // Support blobs\n    a.href = URL.createObjectURL(blob);\n    setTimeout(function () {\n      URL.revokeObjectURL(a.href);\n    }, 4E4); // 40s\n\n    setTimeout(function () {\n      click(a);\n    }, 0);\n  }\n} // Use msSaveOrOpenBlob as a second approach\n: 'msSaveOrOpenBlob' in navigator ? function saveAs(blob, name, opts) {\n  name = name || blob.name || 'download';\n\n  if (typeof blob === 'string') {\n    if (corsEnabled(blob)) {\n      download(blob, name, opts);\n    } else {\n      var a = document.createElement('a');\n      a.href = blob;\n      a.target = '_blank';\n      setTimeout(function () {\n        click(a);\n      });\n    }\n  } else {\n    navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n  }\n} // Fallback to using FileReader and a popup\n: function saveAs(blob, name, opts, popup) {\n  // Open a popup immediately do go around popup blocker\n  // Mostly only available on user interaction and the fileReader is async so...\n  popup = popup || open('', '_blank');\n\n  if (popup) {\n    popup.document.title = popup.document.body.innerText = 'downloading...';\n  }\n\n  if (typeof blob === 'string') return download(blob, name, opts);\n  var force = blob.type === 'application/octet-stream';\n\n  var isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari;\n\n  var isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n\n  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== 'undefined') {\n    // Safari doesn't allow downloading of blob URLs\n    var reader = new FileReader();\n\n    reader.onloadend = function () {\n      var url = reader.result;\n      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n      if (popup) popup.location.href = url;else location = url;\n      popup = null; // reverse-tabnabbing #460\n    };\n\n    reader.readAsDataURL(blob);\n  } else {\n    var URL = _global.URL || _global.webkitURL;\n    var url = URL.createObjectURL(blob);\n    if (popup) popup.location = url;else location.href = url;\n    popup = null; // reverse-tabnabbing #460\n\n    setTimeout(function () {\n      URL.revokeObjectURL(url);\n    }, 4E4); // 40s\n  }\n});\n_global.saveAs = saveAs.saveAs = saveAs;\n\nif (true) {\n  module.exports = saveAs;\n}\n\n//# sourceURL=webpack://sten/./libs/FileSaver.js?");

/***/ }),

/***/ "./src/builder.js":
/*!************************!*\
  !*** ./src/builder.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction escapeClassName(className) {\n  //return className.replace(/[^a-zA-Z0-9_-]/g, \"\");\n  // ei toimi firefoxin inspectorilla\n  return className.replace(/./g, function (_char) {\n    if (_char.match(/[a-zA-Z0-9_-]/)) {\n      return _char;\n    } else if (_char in [\"!\", '\"', \"#\", \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \"-\", \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\", \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"`\", \"{\", \"|\", \"}\", \"~\"]) {\n      return \"\\\\\" + _char;\n    } else {\n      return \"\\\\\" + parseInt(_char.charCodeAt(0), 16);\n    }\n  });\n}\n\nfunction getBarClass(barSymbol) {\n  switch (barSymbol) {\n    case \"|\":\n      return \"bar\";\n\n    case \"¦\":\n      return \"bar-2\";\n\n    case \" \":\n      return \"bar-space\";\n  }\n\n  throw new Exception(\"Tuntematon bar-symboli: \" + barSymbol);\n}\n\nfunction getTd(blockData) {\n  console.log(\"BOCK\", blockData);\n  var text = blockData.text.trim();\n\n  if (text === \"\") {\n    text = \"&ZeroWidthSpace;\";\n  }\n\n  var texts = text.split(/(\\$)/g);\n  var domTexts = texts.map(function (piece) {\n    if (piece === '$') {\n      return '<span class=\"spacer\"></span>';\n    } else {\n      return piece;\n    }\n  });\n  var $td = $('<td></td>').append(domTexts);\n\n  if (blockData.index === 0 && text.match(\"^([A-H][♭♯#b]?)\")) {\n    $td.addClass(\"chord\");\n  }\n\n  if (blockData.halfBar) {\n    $td.addClass(getBarClass(blockData.halfBar));\n  }\n\n  return $td;\n}\n\nfunction $buildMeasureBlock(measureBlock) {\n  var $table = $('<table class=\"measure-block\"></table>');\n\n  if (measureBlock.spaceAfter) {\n    $table.addClass(\"bar-end\");\n  }\n\n  if (measureBlock.rows[0].bar) {\n    $table.addClass(getBarClass(measureBlock.rows[0].bar));\n  }\n\n  var $rows = measureBlock.rows.map(function (row) {\n    return $('<tr></tr>').addClass(\"line-\" + row.index).append(getTd(row));\n  });\n  $table.append($rows);\n  return $table;\n}\n\nfunction $handlePhrase(phrase) {\n  var $phrase = $('<p class=\"phrase\"></p>');\n  $phrase.append(phrase.measures.map($buildMeasureBlock));\n  return $phrase;\n}\n\nfunction $handleSection(section) {\n  var $section = $('<div class=\"section\"></div>');\n\n  if (section.phrases.length === 0) {\n    return $section;\n  }\n\n  if (section.title) {\n    $section.append($(\"<h2></h2>\").text(section.title));\n    $section.addClass(escapeClassName(section.title));\n  }\n\n  $section.append(section.phrases.map($handlePhrase));\n  return $section;\n}\n\nfunction build($doc, parsedDoc) {\n  var $h1 = $(\"<h1>\" + (parsedDoc.title || \"\") + \"</h1>\");\n\n  if (parsedDoc.rightTitle) {\n    $h1.append('<span class=\"right\">' + parsedDoc.rightTitle + '</span>');\n  }\n\n  $doc.html(\"\");\n\n  if (parsedDoc.title || parsedDoc.rightTitle) {\n    $doc.append($h1);\n  }\n\n  parsedDoc.sections.forEach(function (sectionData) {\n    $doc.append($handleSection(sectionData));\n  });\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  build: build\n});\n\n//# sourceURL=webpack://sten/./src/builder.js?");

/***/ }),

/***/ "./src/englishGerman.js":
/*!******************************!*\
  !*** ./src/englishGerman.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar englishNotes = ['B𝄪', 'B♯', 'B', 'B♭', 'B𝄫'];\nvar germanNotes = ['H𝄪', 'H♯', 'H', 'B', 'B♭'];\n\nfunction germanToEnglish(germanNotename) {\n  if (germanNotename === 'B𝄫') {\n    throw new Error(\"No such note: B𝄫 (convention: German)\");\n  }\n\n  var index = germanNotes.indexOf(germanNotename);\n  return englishNotes[index] || germanNotename;\n}\n\nfunction englishToGerman(englishNotename) {\n  var index = englishNotes.indexOf(englishNotename);\n  return germanNotes[index] || englishNotename;\n}\n\nfunction normalizeChord(originalChord, inputConvention) {\n  if (inputConvention === \"B\") {\n    return originalChord;\n  }\n\n  var m = originalChord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)/([A-H](𝄫|𝄪|♭|♯))$\");\n\n  if (!m) {\n    m = originalChord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)$\");\n  }\n\n  if (!m) {\n    throw new Error(\"Not a chord: \" + originalChord);\n  }\n\n  var baseNote = germanToEnglish(m[1]);\n  var quality = m[3];\n  var bassNote = germanToEnglish(m[4]);\n\n  if (bassNote) {\n    return baseNote + quality + \"/\" + bassNote;\n  } else {\n    return baseNote + quality;\n  }\n}\n\nfunction getChordNameInConvention(normalizedChord, outputConvention) {\n  if (outputConvention === \"B\") {\n    return normalizedChord;\n  }\n\n  var m = normalizedChord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)/([A-H](𝄫|𝄪|♭|♯))$\");\n\n  if (!m) {\n    m = normalizedChord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)$\");\n  }\n\n  if (!m) {\n    throw new Error(\"Unrecognizable chord: \" + normalizedChord);\n  }\n\n  var baseNote = m[1];\n  var quality = m[3];\n  var bassNote = m[4];\n\n  if (baseNote.startsWith(\"H\") || bassNote && bassNote.startsWith(\"H\")) {\n    throw new Error(\"H note where English notes expected\");\n  }\n\n  baseNote = englishToGerman(baseNote);\n  bassNote = englishToGerman(bassNote);\n\n  if (bassNote) {\n    return baseNote + quality + \"/\" + bassNote;\n  } else {\n    return baseNote + quality;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getChordNameInConvention: getChordNameInConvention,\n  normalizeChord: normalizeChord\n});\n\n//# sourceURL=webpack://sten/./src/englishGerman.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _englishGerman_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./englishGerman.js */ \"./src/englishGerman.js\");\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser.js */ \"./src/parser.js\");\n/* harmony import */ var _builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./builder.js */ \"./src/builder.js\");\n/* harmony import */ var _transponation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transponation.js */ \"./src/transponation.js\");\n/* harmony import */ var _libs_FileSaver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../libs/FileSaver.js */ \"./libs/FileSaver.js\");\n/* harmony import */ var _libs_FileSaver_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_libs_FileSaver_js__WEBPACK_IMPORTED_MODULE_4__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n // Hooks run after render.\n\nvar renderHooks = [];\n\nfunction clearRenderError() {\n  if ($(\"#message-bar-render\").data('timer')) {\n    clearTimeout($(\"#message-bar-render\").data('timer'));\n  }\n\n  $(\"#message-bar-render\").fadeOut();\n}\n\nfunction setRenderError(errorMessage) {\n  clearRenderError();\n  $(\"#message-bar-render\").html(errorMessage);\n  $(\"#message-bar-render\").data('timer', setTimeout(clearRenderError, 5000));\n  $(\"#message-bar-render\").show();\n}\n\nfunction clearEditError() {\n  if ($(\"#message-bar-edit\").data('timer')) {\n    clearTimeout($(\"#message-bar-edit\").data('timer'));\n  }\n\n  $(\"#message-bar-edit\").fadeOut();\n}\n\nfunction setEditError(errorMessage) {\n  clearEditError();\n  $(\"#message-bar-edit\").html(errorMessage);\n  $(\"#message-bar-edit\").data('timer', setTimeout(clearEditError, 5000));\n  $(\"#message-bar-edit\").show();\n}\n\nfunction getChords() {\n  var $chordElems = $('.chord');\n  var chords = [];\n  $chordElems.each(function () {\n    var chordName = $(this).attr('data-normalized');\n    chords.push(chordName);\n  });\n  return chords;\n}\n\nfunction conventionalizeOutput() {\n  var convention = getOutputConvention();\n\n  if (convention === \"B\") {\n    return;\n  }\n\n  var $chordElems = $('.chord');\n  $chordElems.each(function () {\n    var normalizedName = $(this).text().replace(\" \", \"\");\n    var conventionalizedChord = _englishGerman_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getChordNameInConvention(normalizedName, convention);\n    $(this).text(conventionalizedChord);\n  });\n}\n\nfunction mapChords(mapping) {\n  var $chordElems = $('.chord');\n  $chordElems.each(function () {\n    var normalizedName = $(this).data(\"normalized\");\n    var transponatedChord = mapping[normalizedName];\n\n    if (!transponatedChord) {\n      throw new Error(\"No mapping for chord \" + normalizedName);\n    }\n\n    $(this).text(transponatedChord);\n  });\n}\n\nfunction doTransponation() {\n  var amount = parseInt($(\"#transponate-amount\").val(), 10);\n  var prevValue = $(\"#transponate-amount\").data('previous-value') || \"0\";\n  var prevAmount = parseInt(prevValue, 10);\n  var dir = amount - prevAmount;\n\n  if (Number.isNaN(amount) || amount === 0) {\n    return;\n  }\n\n  var chords = getChords();\n  var chordMapping;\n\n  try {\n    chordMapping = _transponation_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getChordMapping(chords, amount, dir);\n  } catch (error) {\n    setRenderError(error);\n    return;\n  }\n\n  mapChords(chordMapping);\n  var doubleSharp = Object.values(chordMapping).filter(function (chordName) {\n    return chordName.indexOf(\"𝄪\") > -1;\n  });\n  var doubleFlat = Object.values(chordMapping).filter(function (chordName) {\n    return chordName.indexOf(\"𝄫\") > -1;\n  });\n\n  if (doubleSharp.length > 0) {\n    $(\"#double-sharp-indicator\").show();\n  } else {\n    $(\"#double-sharp-indicator\").hide();\n  }\n\n  if (doubleFlat.length > 0) {\n    $(\"#double-flat-indicator\").show();\n  } else {\n    $(\"#double-flat-indicator\").hide();\n  }\n\n  $(\"#transponate-amount\").data('previous-value', amount);\n}\n\nfunction prepareParseTree(parsedDoc) {\n  if (!parsedDoc.sections) {\n    return;\n  }\n\n  var _iterator = _createForOfIteratorHelper(parsedDoc.sections),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var section = _step.value;\n\n      var _iterator2 = _createForOfIteratorHelper(section.phrases),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var phrase = _step2.value;\n          var prevMeasure = phrase.measures[0];\n\n          var _iterator3 = _createForOfIteratorHelper(phrase.measures.slice(1)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var measure = _step3.value;\n\n              if (measure.rows[0].bar !== null) {\n                prevMeasure.spaceAfter = true;\n              }\n\n              prevMeasure = measure;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction render() {\n  var text = $(\"textarea\").val();\n  var $doc = $(\"#rendered\");\n  var parsedDoc = _parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(text);\n  prepareParseTree(parsedDoc);\n  _builder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].build($doc, parsedDoc);\n\n  if (parsedDoc.title && parsedDoc.rightTitle) {\n    $(\"title\").text(parsedDoc.title + \" — \" + parsedDoc.rightTitle);\n  } else if (parsedDoc.title) {\n    $(\"title\").text(parsedDoc.title);\n  } else if (parsedDoc.rightTitle) {\n    $(\"title\").text(parsedDoc.rightTitle);\n  } else {\n    $(\"title\").text(\"Untitled\");\n  }\n\n  for (var i in renderHooks) {\n    try {\n      renderHooks[i]();\n    } catch (error) {\n      console.error(\"Render hook error:\", error);\n      return;\n    }\n  }\n}\n/**\n * Check that the given input only has chords from the selected note name convention.\n **/\n\n\nfunction checkConvention() {\n  var $chords = $('.chord');\n  var culture = getInputConvention();\n  $chords.each(function () {\n    var text = $(this).data('normalized-original');\n    var m = text.match(\"^([A-H][♭♯𝄫𝄪]?)(.*?)/([A-H][♭♯𝄫𝄪]?)$\");\n\n    if (!m) {\n      m = text.match(\"^([A-H][♭♯𝄫𝄪]?)(.*)()$\");\n    }\n\n    if (m && m[1].startsWith('H') && culture !== 'H') {\n      setEditError('Error: Source has chord ' + text + ' but note name convention is not set to ”German H, B”.');\n    } else if (m && m[3].startsWith('H') && culture !== 'H') {\n      setEditError('Error: Source has note ' + text + ' but note name convention is not set to ”German H, B”.');\n    } else if (m && m[1].startsWith('B𝄫') && culture !== 'B') {\n      setEditError('Error: Source has chord ' + text + ' but note name convention is not set to ”English B, B♭”.');\n    } else if (m && m[3] === 'B𝄫' && culture !== 'B') {\n      setEditError('Error: Source has note ' + text + ' but note name convention is not set to ”English B, B♭”.');\n    }\n  });\n}\n\nfunction runRenderAndCheck() {\n  render();\n  checkConvention();\n}\n\nfunction getCurrentFilename() {\n  var loadBtn = document.getElementById(\"load-button\");\n\n  if (loadBtn.files.length > 0) {\n    return loadBtn.files[0].name;\n  }\n\n  return null;\n}\n\nfunction saveSourceFile() {\n  var content = $(\"textarea\").val();\n  var filename = getCurrentFilename() || $(\"title\").html() + \".txt\";\n  var blob = new Blob([content], {\n    type: \"text/plain;charset=utf-8\"\n  });\n  (0,_libs_FileSaver_js__WEBPACK_IMPORTED_MODULE_4__.saveAs)(blob, filename);\n}\n\nfunction loadSourceFile() {\n  var reader = new FileReader();\n  reader.readAsText(document.getElementById(\"load-button\").files[0]);\n\n  reader.onload = function (event) {\n    $(\"textarea\").val(event.target.result);\n    render();\n  };\n}\n\nfunction exportHtml() {\n  // TODO formatointi\n  var content = $(\"#rendered\").html().replace(\"</h1>\", \"</h1>\\n\\n\").replace(\"</h2>\", \"</h2>\\n\\n\").replace(\"</p>\", \"</p>\\n\\n\").replace(\"</div>\", \"</div>\\n\\n\");\n  var filename = $(\"title\").html() + \".html\";\n  var blob = new Blob([content], {\n    type: \"text/html;charset=utf-8\"\n  });\n  (0,_libs_FileSaver_js__WEBPACK_IMPORTED_MODULE_4__.saveAs)(blob, filename);\n}\n\nfunction toggleHelp() {\n  if ($(\"#toggle-help-button\").text() === \"Hide Help\") {\n    $(\"#help\").slideUp();\n    $(\"#toggle-help-button\").text(\"Show Help\");\n    localStorage.setItem(\"show-help\", \"no\");\n  } else {\n    $(\"#help\").slideDown();\n    $(\"#toggle-help-button\").text(\"Hide Help\");\n    localStorage.setItem(\"show-help\", \"yes\");\n  }\n}\n\nfunction disableExtraStyleSheets() {\n  var $styleSheets = $(\".extra-style-sheet\");\n  $styleSheets.each(function () {\n    var $styleSheet = $(this);\n    var href = $styleSheet.attr(\"href\");\n    $styleSheet.attr(\"data-href\", href);\n    $styleSheet.attr(\"href\", \"\");\n  });\n}\n\nfunction populateStyleSheetSelector() {\n  var $styleSheets = $(\".extra-style-sheet\");\n  var $styleSheetSelect = $(\"#style-sheet-selector\");\n  var selectedStyleSheet = localStorage.getItem(\"style-sheet\") || $styleSheets.first().attr(\"id\");\n  $styleSheets.each(function () {\n    var $styleSheet = $(this);\n    $styleSheetSelect.append($(\"<option>\", {\n      value: $styleSheet.attr(\"id\"),\n      text: $styleSheet.attr(\"data-description\") || $styleSheet.attr(\"id\"),\n      selected: selectedStyleSheet === $styleSheet.attr(\"id\")\n    }));\n  });\n}\n\nfunction changeStyleSheet() {\n  var $extraStyleSheets = $(\".extra-style-sheet\");\n  var $styleSheetSelect = $(\"#style-sheet-selector\");\n  var selectedStyleSheetId = $styleSheetSelect.val();\n  var $selectedStyleSheet = $(\"#\" + selectedStyleSheetId);\n  localStorage.setItem(\"style-sheet\", selectedStyleSheetId);\n  $extraStyleSheets.attr(\"href\", \"\");\n  $selectedStyleSheet.attr(\"href\", $selectedStyleSheet.attr(\"data-href\"));\n  changeFontSize();\n}\n\nfunction changeFontSize() {\n  var $div = $(\"#rendered\");\n  $div.css({\n    fontSize: $('#font-size-input').val() + \"%\"\n  });\n}\n/**\n * Saves the original (before transponation) chord name in a normalized\n * format to the element.\n **/\n\n\nfunction saveNormalizedFormOfChords() {\n  var convention = getInputConvention();\n  $('.chord').each(function () {\n    var normalizedOriginalName = $(this).text().replaceAll(\"##\", \"𝄪\").replaceAll(\"bb\", \"𝄫\").replaceAll(\"#\", \"♯\").replaceAll(\"b\", \"♭\");\n    var normalizedName;\n\n    try {\n      normalizedName = _englishGerman_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].normalizeChord(normalizedOriginalName, convention);\n    } catch (error) {\n      setEditError(error);\n      return;\n    }\n\n    $(this).attr('data-normalized-original', normalizedOriginalName);\n    $(this).attr('data-normalized', normalizedName);\n  });\n}\n\nfunction fancifyChords() {\n  $('.chord').each(function () {\n    var normalizedName = $(this).attr('data-normalized');\n    $(this).text(normalizedName.replace(/([A-H][♯♭]?)([^♯♭ ])/, '$1 $2') // insert hair space U+200A after root name \n    .replace(/(sus|add|aug|dim|non|no)(.)/, '$1 $2'));\n  });\n}\n\nfunction getInputConvention() {\n  return $('#input-convention-selector').val();\n}\n\nfunction getOutputConvention() {\n  return $('#output-convention-selector').val();\n}\n\nfunction changeOutputConvention() {\n  localStorage.setItem(\"output-convention\", getOutputConvention());\n  render();\n}\n\nfunction changeInputConvention() {\n  localStorage.setItem(\"input-convention\", getInputConvention());\n}\n\nfunction testParser() {\n  var text = $(\"textarea\").val();\n  var parsedDoc = _parser_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(text);\n  prepareParseTree(parsedDoc);\n  alert(JSON.stringify(parsedDoc, null, 2));\n}\n\njQuery(document).ready(function () {\n  //disableExtraStyleSheets();\n  populateStyleSheetSelector();\n  changeStyleSheet();\n  $(\"#save-button\").on('click', saveSourceFile);\n  $(\"#load-button\").on('change', loadSourceFile);\n  $(\"#render-button\").on('click', runRenderAndCheck);\n  $(\"#export-html-button\").on('click', exportHtml);\n  $(\"#toggle-help-button\").on('click', toggleHelp);\n\n  if (localStorage.getItem(\"show-help\") === \"no\") {\n    $(\"#toggle-help-button\").text(\"Show Help\");\n    $(\"#help\").hide();\n  }\n\n  $(\"#style-sheet-selector\").on('change', changeStyleSheet);\n  $(\"#font-size-input\").on('change', changeFontSize);\n  $(\"#transponate-amount\").on('change', function (event) {\n    var oldTimeoutHandle = $(this).data('transponation-delay');\n    clearTimeout(oldTimeoutHandle);\n    var newTimeoutHandle = setTimeout(render, 500);\n    $(this).data('transponation-delay', newTimeoutHandle);\n  });\n  $(\"#input-convention-selector\").on('change', changeInputConvention);\n\n  if (localStorage.getItem(\"input-convention\") === \"H\") {\n    $(\"#input-convention-selector\").val(\"H\");\n  }\n\n  $(\"#output-convention-selector\").on('change', changeOutputConvention);\n\n  if (localStorage.getItem(\"output-convention\") === \"H\") {\n    $(\"#output-convention-selector\").val(\"H\");\n  }\n\n  if (window.location.search.indexOf(\"debug=1\") > -1) {\n    $(\"#test-button\").on('click', testParser);\n  } else {\n    $(\"#test-button\").remove();\n  } // Functions to run after rendering.\n\n\n  renderHooks.push(saveNormalizedFormOfChords);\n  renderHooks.push(fancifyChords);\n  renderHooks.push(doTransponation);\n  renderHooks.push(conventionalizeOutput);\n  render();\n});\n\n//# sourceURL=webpack://sten/./src/index.js?");

/***/ }),

/***/ "./src/parser.js":
/*!***********************!*\
  !*** ./src/parser.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction transpose(inputArray) {\n  var outputArray = [];\n\n  if (inputArray.length === 0) {\n    return [];\n  }\n\n  for (var colIndex = 0; colIndex < inputArray[0].length; colIndex++) {\n    outputArray[colIndex] = [];\n\n    for (var rowIndex = 0; rowIndex < inputArray.length; rowIndex++) {\n      outputArray[colIndex][rowIndex] = inputArray[rowIndex][colIndex];\n    }\n  }\n\n  return outputArray;\n}\n/**\n * \"Luonnolliset\" jakokohdat.\n *\n * Sanojen alkukohdat.\n */\n\n\nfunction get_breaks(str) {\n  var point;\n  var breaks = []; // Two spaces before non-space.\n\n  var re = new RegExp(/  [^ ]/g);\n  var match;\n\n  while ((match = re.exec(str)) !== null) {\n    point = match.index;\n    breaks.push(point + 2);\n  }\n\n  return breaks;\n}\n/**\n * Putkimerkillä merkityt pakotetut kohdat.\n **/\n\n\nfunction get_forced_breaks(str) {\n  var point;\n  var breaks = [];\n  var re = new RegExp(/[|¦]/g);\n  var match;\n\n  while ((match = re.exec(str)) !== null) {\n    point = match.index;\n    breaks.push(point);\n    breaks.push(point + 1);\n  }\n\n  return breaks;\n}\n/* finds the intersection of \n * two arrays in a simple fashion.  \n *\n * PARAMS\n *  a - first array, must already be sorted\n *  b - second array, must already be sorted\n *\n * NOTES\n *\n *  Should have O(n) operations, where n is \n *    n = MIN(a.length(), b.length())\n */\n\n\nfunction intersect_safe(a, b) {\n  var ai = 0,\n      bi = 0;\n  var result = [];\n\n  while (ai < a.length && bi < b.length) {\n    if (a[ai] < b[bi]) {\n      ai++;\n    } else if (a[ai] > b[bi]) {\n      bi++;\n    } else\n      /* they're equal */\n      {\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      }\n  }\n\n  return result;\n}\n\nfunction union_arrays(x, y) {\n  var obj = {};\n\n  for (var i = x.length - 1; i >= 0; --i) {\n    obj[x[i]] = x[i];\n  }\n\n  for (var i = y.length - 1; i >= 0; --i) {\n    obj[y[i]] = y[i];\n  }\n\n  var res = [];\n\n  for (var k in obj) {\n    if (obj.hasOwnProperty(k)) // <-- optional\n      res.push(obj[k]);\n  }\n\n  return res;\n}\n\nfunction unionAll(arrays) {\n  return arrays.reduce(union_arrays, []);\n}\n\nfunction intersectAll(arrays) {\n  return arrays.reduce(intersect_safe, arrays[0] || []);\n}\n\nfunction parseLineGroup(lines, firstIndex) {\n  var lineGroup = {\n    lines: lines,\n    breaks: null,\n    firstIndex: firstIndex\n  };\n  var linesWithBreakInfo = lines.map(function (line, index) {\n    return {\n      text: line,\n      naturalBreaks: get_breaks(line),\n      forcedBreaks: get_forced_breaks(line)\n    };\n  });\n  var naturalBreaksPerRow = linesWithBreakInfo.map(function (item) {\n    return item.naturalBreaks;\n  });\n  var forcedBreaksPerRow = linesWithBreakInfo.map(function (item) {\n    return item.forcedBreaks;\n  });\n  var combinedForcedBreaks = unionAll(forcedBreaksPerRow); //var combinedNaturalBreaks = intersectAll(naturalBreaksPerRow);\n\n  var combinedNaturalBreaks = unionAll(naturalBreaksPerRow); //combinedNaturalBreaks = get_breaks(lineGroup.lines[0]);\n\n  lineGroup.breaks = union_arrays(combinedNaturalBreaks, combinedForcedBreaks);\n  return lineGroup;\n}\n\nfunction split_string(str, breaks, ank) {\n  var out = [];\n  var start = 0;\n  breaks.forEach(function (brk) {\n    out.push(str.substring(start, brk));\n    start = brk;\n  });\n  out.push(str.substring(start));\n  return out;\n}\n\nfunction getBlock(rowsOfPart, barSymbol, firstLineNumber) {\n  var block = {};\n  block.rows = rowsOfPart.map(function (rowOfPart, index) {\n    var text = rowOfPart;\n    var halfBar = undefined;\n\n    if (barSymbol === null && (rowOfPart === \"|\" || rowOfPart === \"¦\")) {\n      // To display bar only on this line\n      halfBar = rowOfPart;\n      text = \"\";\n    }\n\n    return {\n      index: index - firstLineNumber,\n      text: text,\n      bar: barSymbol,\n      halfBar: halfBar\n    };\n  });\n  return block;\n}\n\nfunction hasBar(barType, linesForParts) {\n  var hasBar = false; // Check that at least one line has the bar character (|, ¦) and the rest are empty (\"\" or \" \"). IF\n  // one line ends before other, it has \"\".\n\n  var _iterator = _createForOfIteratorHelper(linesForParts),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var lineForPart = _step.value;\n\n      if (lineForPart === barType) {\n        hasBar = true;\n      } else if (lineForPart !== \"\" && lineForPart !== \" \") {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return hasBar;\n}\n\nfunction replaceStartAndEndSpaces(linesOfPart, hasBarBefore) {\n  var starts = linesOfPart.map(function (part) {\n    if (hasBarBefore) {\n      return 0;\n    }\n\n    var match = part.match(/^ +/);\n\n    if (match) {\n      return match[0].length;\n    }\n\n    return 0;\n  });\n  var ends = linesOfPart.map(function (part) {\n    var match = part.match(/  +$/);\n\n    if (match) {\n      return match[0].length;\n    }\n\n    return 0;\n  });\n  var lenStarts = starts.reduce(function (acc, val) {\n    return Math.min(acc, val);\n  });\n  var lenEnds = ends.reduce(function (acc, val) {\n    return Math.min(acc, val);\n  });\n  console.log(starts, ends, lenStarts, lenEnds);\n  var out = linesOfPart.map(function (lineForPart) {\n    // Merkki @ toimii näkymättömänä ankkurina.\n    lineForPart = lineForPart.replace(/^ +/, '@'.repeat(lenStarts));\n    lineForPart = lineForPart.replace(/  +$/, '@'.repeat(lenEnds));\n    return lineForPart.replace(/@/g, \"&nbsp;\");\n  });\n  return out;\n}\n\nfunction parseMeasures(lineBlock) {\n  var out = [];\n  var breaks = lineBlock.breaks;\n  var parts = lineBlock.lines.map(function (line) {\n    return split_string(line, breaks);\n  });\n  var i;\n  var bar = null; // Each part group is a list of of aligned parts on each lines.\n\n  var partGroups = transpose(parts);\n  var halfBar = true;\n  partGroups.forEach(function (linesOfPart, index) {\n    linesOfPart = replaceStartAndEndSpaces(linesOfPart, !!bar || halfBar);\n    console.log(\"lines for parts:\", linesOfPart); // Ohitetaan tyhjät.\n\n    if (linesOfPart.every(function (lineForPart) {\n      return lineForPart === \" \";\n    })) {\n      return out;\n    } else if (hasBar(\"|\", linesOfPart)) {\n      bar = \"|\";\n    } else if (hasBar(\"¦\", linesOfPart)) {\n      bar = \"¦\";\n    } else {\n      if (linesOfPart.every(function (lineForPart) {\n        return lineForPart.match(/^  +$/);\n      })) {\n        linesOfPart = linesOfPart.map(function (lineForPart) {\n          return lineForPart.replaceAll(\" \", \"$\");\n        });\n      }\n\n      var measureBlock = getBlock(linesOfPart, bar, lineBlock.firstIndex);\n      out.push(measureBlock); // If all lines end in space, mark as bar so we can get a space after the measure.\n\n      if (linesOfPart.every(function (lineForPart) {\n        return lineForPart.endsWith(\" \");\n      })) {\n        bar = \" \";\n      } else {\n        bar = null;\n      }\n\n      if (linesOfPart.some(function (lineForPart) {\n        return lineForPart.indexOf(\"|\") > -1;\n      })) {\n        halfBar = true;\n      } else {\n        halfBar = false;\n      }\n    }\n  });\n  return out;\n}\n\nfunction parsePhrase(text) {\n  var phrase = {\n    measures: [{\n      rows: [],\n      breaks: [],\n      firstIndex: 0\n    }]\n  };\n\n  if (text === \"\") {\n    return acc;\n  }\n\n  console.assert(text.indexOf(\"\\n\\n\") === -1, \"tyhjiä rivejä\");\n  var lines = text.split(\"\\n\").filter(function (line) {\n    return line.trim() !== \"\";\n  });\n  var positiveStartIndex = lines.findIndex(function (line) {\n    return line.trimEnd() === \"#0\";\n  });\n\n  if (positiveStartIndex === -1) {\n    positiveStartIndex = 0;\n  }\n\n  var regularLines = lines.filter(function (line) {\n    return line.trimEnd() !== \"#0\";\n  });\n  var lineBlock = parseLineGroup(regularLines, positiveStartIndex);\n  phrase.measures = parseMeasures(lineBlock);\n  return phrase;\n}\n\nfunction parseSection(text) {\n  var section = {\n    title: null,\n    phrases: []\n  };\n  var phrases = text.split(/\\n\\n\\n*/).filter(function (text) {\n    return text !== \"\";\n  });\n\n  if (phrases.length === 0) {\n    return section;\n  }\n\n  var m = phrases[0].match(/^\\n*#section ?(.*)/);\n\n  if (m) {\n    section.title = m[1];\n    phrases.shift();\n  }\n\n  section.phrases = phrases.map(parsePhrase);\n  return section;\n}\n\nfunction readPragma(pragmaName, text) {\n  var m = text.match(new RegExp('^\\n*#' + pragmaName + '(.*)\\n'));\n\n  if (m) {\n    return m[1];\n  }\n\n  return null;\n}\n\nfunction removePragma(pragmaName, text) {\n  return text.replace(new RegExp('^\\n*#' + pragmaName + '(.*?)\\n+'), \"\");\n}\n\nfunction parse(text) {\n  var doc = {\n    title: null,\n    rightTitle: null,\n    sections: []\n  };\n  doc.title = readPragma(\"title\", text);\n  text = removePragma(\"title\", text);\n  doc.rightTitle = readPragma(\"right\", text);\n  text = removePragma(\"right\", text);\n  text = text.replace(/^\\n+/, \"\");\n  var sections = text.split(/\\n(?=#section)/);\n  sections.forEach(function (sectionText) {\n    doc.sections.push(parseSection(sectionText));\n  });\n  return doc;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  parse: parse\n});\n\n//# sourceURL=webpack://sten/./src/parser.js?");

/***/ }),

/***/ "./src/transponation.js":
/*!******************************!*\
  !*** ./src/transponation.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar values = {\n  \"C\": {\n    index: 0,\n    pos: 0\n  },\n  \"C♯\": {\n    index: 1,\n    pos: 0\n  },\n  \"C𝄪\": {\n    index: 2,\n    pos: 0\n  },\n  \"D𝄫\": {\n    index: 0,\n    pos: 1\n  },\n  \"D♭\": {\n    index: 1,\n    pos: 1\n  },\n  \"D\": {\n    index: 2,\n    pos: 1\n  },\n  \"D♯\": {\n    index: 3,\n    pos: 1\n  },\n  \"D𝄪\": {\n    index: 4,\n    pos: 1\n  },\n  \"E𝄫\": {\n    index: 2,\n    pos: 2\n  },\n  \"E♭\": {\n    index: 3,\n    pos: 2\n  },\n  \"E\": {\n    index: 4,\n    pos: 2\n  },\n  \"E♯\": {\n    index: 5,\n    pos: 2\n  },\n  \"E𝄪\": {\n    index: 6,\n    pos: 2\n  },\n  \"F𝄫\": {\n    index: 3,\n    pos: 3\n  },\n  \"F♭\": {\n    index: 4,\n    pos: 3\n  },\n  \"F\": {\n    index: 5,\n    pos: 3\n  },\n  \"F♯\": {\n    index: 6,\n    pos: 3\n  },\n  \"F𝄪\": {\n    index: 7,\n    pos: 3\n  },\n  \"G𝄫\": {\n    index: 5,\n    pos: 4\n  },\n  \"G♭\": {\n    index: 6,\n    pos: 4\n  },\n  \"G\": {\n    index: 7,\n    pos: 4\n  },\n  \"G♯\": {\n    index: 8,\n    pos: 4\n  },\n  \"G𝄪\": {\n    index: 9,\n    pos: 4\n  },\n  \"A𝄫\": {\n    index: 7,\n    pos: 5\n  },\n  \"A♭\": {\n    index: 8,\n    pos: 5\n  },\n  \"A\": {\n    index: 9,\n    pos: 5\n  },\n  \"A♯\": {\n    index: 10,\n    pos: 5\n  },\n  \"A𝄪\": {\n    index: 11,\n    pos: 5\n  },\n  \"B𝄫\": {\n    index: 9,\n    pos: 6\n  },\n  \"B♭\": {\n    index: 10,\n    pos: 6\n  },\n  \"B\": {\n    index: 11,\n    pos: 6\n  },\n  \"B♯\": {\n    index: 0,\n    pos: 6\n  },\n  \"B𝄪\": {\n    index: 1,\n    pos: 6\n  },\n  \"C𝄫\": {\n    index: 10,\n    pos: 0\n  },\n  \"C♭\": {\n    index: 11,\n    pos: 0\n  }\n};\nvar intervals = {\n  \"dd1\": {\n    index: -2,\n    pos: 0\n  },\n  \"d1\": {\n    index: -1,\n    pos: 0\n  },\n  \"P1\": {\n    index: 0,\n    pos: 0\n  },\n  \"A1\": {\n    index: 1,\n    pos: 0\n  },\n  \"AA1\": {\n    index: 2,\n    pos: 0\n  },\n  \"dd2\": {\n    index: -1,\n    pos: 1\n  },\n  \"d2\": {\n    index: 0,\n    pos: 1\n  },\n  \"m2\": {\n    index: 1,\n    pos: 1\n  },\n  \"M2\": {\n    index: 2,\n    pos: 1\n  },\n  \"A2\": {\n    index: 3,\n    pos: 1\n  },\n  \"AA2\": {\n    index: 4,\n    pos: 1\n  },\n  \"dd3\": {\n    index: 1,\n    pos: 2\n  },\n  \"d3\": {\n    index: 2,\n    pos: 2\n  },\n  \"m3\": {\n    index: 3,\n    pos: 2\n  },\n  \"M3\": {\n    index: 4,\n    pos: 2\n  },\n  \"A3\": {\n    index: 5,\n    pos: 2\n  },\n  \"AA3\": {\n    index: 6,\n    pos: 2\n  },\n  \"dd4\": {\n    index: 3,\n    pos: 3\n  },\n  \"d4\": {\n    index: 4,\n    pos: 3\n  },\n  \"P4\": {\n    index: 5,\n    pos: 3\n  },\n  \"A4\": {\n    index: 6,\n    pos: 3\n  },\n  \"AA4\": {\n    index: 7,\n    pos: 3\n  },\n  \"dd5\": {\n    index: 5,\n    pos: 4\n  },\n  \"d5\": {\n    index: 6,\n    pos: 4\n  },\n  \"P5\": {\n    index: 7,\n    pos: 4\n  },\n  \"A5\": {\n    index: 8,\n    pos: 4\n  },\n  \"AA5\": {\n    index: 9,\n    pos: 4\n  },\n  \"dd6\": {\n    index: 6,\n    pos: 5\n  },\n  \"d6\": {\n    index: 7,\n    pos: 5\n  },\n  \"m6\": {\n    index: 8,\n    pos: 5\n  },\n  \"M6\": {\n    index: 9,\n    pos: 5\n  },\n  \"A6\": {\n    index: 10,\n    pos: 5\n  },\n  \"AA6\": {\n    index: 11,\n    pos: 5\n  },\n  \"dd7\": {\n    index: 8,\n    pos: 6\n  },\n  \"d7\": {\n    index: 9,\n    pos: 6\n  },\n  \"m7\": {\n    index: 10,\n    pos: 6\n  },\n  \"M7\": {\n    index: 11,\n    pos: 6\n  },\n  \"A7\": {\n    index: 0,\n    pos: 6\n  },\n  \"AA7\": {\n    index: 1,\n    pos: 6\n  }\n};\n\nfunction zip(arr1, arr2) {\n  return arr1.map(function (item, i) {\n    return [item, arr2[i]];\n  });\n}\n\nvar getNoteMappings = function getNoteMappings(notes, amount) {\n  var possibleIntervals = Object.keys(intervals).map(function (key) {\n    return intervals[key];\n  }).filter(function (interval) {\n    return interval.index === amount;\n  });\n  var possibleResult = [];\n\n  var _iterator = _createForOfIteratorHelper(possibleIntervals),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var possibleInterval = _step.value;\n      var transponatedNotes = notes.map(function (note) {\n        var value = values[note];\n\n        if (!value) {\n          throw new Error(\"Unknown note: \" + note);\n        }\n\n        var newIndex = (value.index + possibleInterval.index) % 12;\n        var newPos = (value.pos + possibleInterval.pos) % 7;\n        var possibleNotes = Object.keys(values).filter(function (key) {\n          return values[key].index === newIndex && values[key].pos === newPos;\n        });\n        return possibleNotes[0];\n      }); // If all notes could be transponated.\n\n      if (transponatedNotes.filter(function (transponatedNote) {\n        return !transponatedNote;\n      }).length === 0) {\n        possibleResult.push(Object.fromEntries(zip(notes, transponatedNotes)));\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return possibleResult;\n};\n\nfunction unique(list) {\n  var seen = {};\n\n  var _iterator2 = _createForOfIteratorHelper(list),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n\n      if (item !== undefined) {\n        seen[item] = true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return Object.keys(seen);\n}\n\nfunction rateNotes(notes, dir) {\n  var rate = 0;\n\n  var _iterator3 = _createForOfIteratorHelper(notes),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var note = _step3.value;\n\n      if (note.indexOf(\"𝄪\") > -1 || note.indexOf(\"𝄫\") > -1) {\n        rate--;\n      }\n\n      if (dir > 0 && note.indexOf(\"♭\") > -1) {\n        rate--;\n      } else if (dir > 0 && note.indexOf(\"♯\") > -1) {\n        rate++;\n      } else if (dir < 0 && note.indexOf(\"♯\") > -1) {\n        rate--;\n      } else if (dir > 0 && note.indexOf(\"♭\") > -1) {\n        rate++;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return rate;\n}\n\nfunction selectNoteMap(noteMaps, preferDir) {\n  var rated = [];\n\n  for (var setIndex in noteMaps) {\n    var noteMap = noteMaps[setIndex];\n    var rate = rateNotes(Object.values(noteMap), preferDir);\n    rated.push({\n      noteMap: noteMap,\n      rate: rate\n    });\n  }\n\n  if (rated.length === 0) {\n    throw new Error(\"Could not find transponation\");\n  }\n\n  rated.sort(function (a, b) {\n    return b.rate - a.rate;\n  });\n  return rated[0].noteMap;\n}\n\nvar getChordMapping = function getChordMapping(chords, amount, preferDir) {\n  while (amount < 0) {\n    amount = amount + 12;\n  }\n\n  var nameQualityPairs = chords.map(function (chord) {\n    var m = chord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)/([A-H](𝄫|𝄪|♭|♯)?)$\");\n\n    if (!m) {\n      m = chord.trim().match(\"^([A-H](𝄫|𝄪|♭|♯)?)(.*?)$\");\n    }\n\n    if (!m) {\n      throw new Error(\"Not a chord: \" + chord);\n    }\n\n    return {\n      fullName: chord,\n      baseNote: m[1],\n      quality: m[3],\n      bassNote: m[4]\n    };\n  });\n  var baseNotes = unique(nameQualityPairs.map(function (nameQualityPair) {\n    return nameQualityPair.baseNote;\n  }));\n  var bassNotes = unique(nameQualityPairs.map(function (nameQualityPair) {\n    return nameQualityPair.bassNote;\n  }));\n  var noteNames = unique([].concat(baseNotes, bassNotes));\n  var transponatedNoteMaps = getNoteMappings(noteNames, amount);\n  var noteMap = selectNoteMap(transponatedNoteMaps, preferDir);\n  var chordMapping = {};\n\n  var _iterator4 = _createForOfIteratorHelper(nameQualityPairs),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var chordInfo = _step4.value;\n\n      if (chordInfo.bassNote) {\n        chordMapping[chordInfo.fullName] = noteMap[chordInfo.baseNote] + chordInfo.quality + \"/\" + noteMap[chordInfo.bassNote];\n      } else {\n        chordMapping[chordInfo.fullName] = noteMap[chordInfo.baseNote] + chordInfo.quality;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return chordMapping;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getChordMapping: getChordMapping\n});\n\n//# sourceURL=webpack://sten/./src/transponation.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;